<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Night Jungle - Touch Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; user-select: none; -webkit-user-select: none; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #instructions {
            color: white;
            font-family: 'Arial', sans-serif;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            margin: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            font-size: 14px;
            max-width: 300px;
        }

        /* Mobile Controls UI */
        .controls-zone {
            position: absolute;
            bottom: 40px;
            width: 140px; /* Thoda bada area taki thumb miss na ho */
            height: 140px;
            pointer-events: auto;
            touch-action: none;
            z-index: 10;
        }
        
        /* Left Joystick Zone */
        #stick-container { 
            left: 20px; 
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }

        /* Joystick Knob */
        #joystick-knob {
            position: absolute;
            top: 50%; left: 50%;
            width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Knob movement script se hogi */
        }

        /* Right Look Zone - Poori right side cover karega */
        #look-zone { 
            position: absolute;
            right: 0; bottom: 0;
            width: 50%;  /* Screen ka aadha hissa */
            height: 80%; /* Neeche ka 80% hissa */
            background: rgba(255, 0, 0, 0.0); /* Invisible */
            pointer-events: auto;
            touch-action: none;
        }

        .mobile-hint {
            font-size: 0.8em; color: yellow; margin-top: 5px;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="instructions">
            <h3>Jungle Drive</h3>
            <p>PC: <b>WASD</b> to Move, <b>Mouse</b> to Look</p>
            <p class="mobile-hint">Fixed: Multitouch Supported</p>
        </div>

        <div id="stick-container" class="controls-zone">
            <div id="joystick-knob"></div>
        </div>

        <div id="look-zone"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111122); 
        scene.fog = new THREE.FogExp2(0x111122, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); 
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- 2. ASSETS ---
        function createNoiseTexture(width, height, colorHex) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = colorHex;
            ctx.fillRect(0, 0, width, height);
            
            // Fast Noise
            const imgData = ctx.getImageData(0, 0, width, height);
            const data = imgData.data;
            for (let i = 0; i < data.length; i += 4) {
                if(Math.random() > 0.5) {
                    const grain = (Math.random() - 0.5) * 20; 
                    data[i] = Math.max(0, data[i] + grain);
                    data[i+1] = Math.max(0, data[i+1] + grain);
                    data[i+2] = Math.max(0, data[i+2] + grain);
                }
            }
            ctx.putImageData(imgData, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        const grassTexture = createNoiseTexture(256, 256, '#1a331a');
        grassTexture.repeat.set(50, 50); 
        const roadTexture = createNoiseTexture(256, 256, '#333333');
        roadTexture.repeat.set(1, 40);

        // --- 3. SCENE OBJECTS ---
        const ambientLight = new THREE.AmbientLight(0x404050, 0.7); 
        scene.add(ambientLight);

        const moonLight = new THREE.DirectionalLight(0xaaccff, 0.6);
        moonLight.position.set(50, 100, 50);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.width = 512; // Lower res shadow for mobile
        moonLight.shadow.mapSize.height = 512;
        scene.add(moonLight);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(1000, 1000),
            new THREE.MeshStandardMaterial({ map: grassTexture, roughness: 0.9 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const road = new THREE.Mesh(
            new THREE.PlaneGeometry(12, 1000),
            new THREE.MeshStandardMaterial({ map: roadTexture, roughness: 0.6 })
        );
        road.rotation.x = -Math.PI / 2;
        road.position.y = 0.02;
        road.receiveShadow = true;
        scene.add(road);

        // --- TREES (Instanced) ---
        const treeCount = 400; // Adjusted count
        const treePositions = []; 
        const trunkGeo = new THREE.CylinderGeometry(0.8, 1.2, 4, 5); 
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3c31 });
        const leavesGeo = new THREE.ConeGeometry(3, 8, 5);
        const leavesMat = new THREE.MeshStandardMaterial({ color: 0x0f3d0f });

        const trunkMesh = new THREE.InstancedMesh(trunkGeo, trunkMat, treeCount);
        const leavesMesh = new THREE.InstancedMesh(leavesGeo, leavesMat, treeCount);
        trunkMesh.castShadow = true; trunkMesh.receiveShadow = true;
        leavesMesh.castShadow = true; leavesMesh.receiveShadow = true;

        const dummy = new THREE.Object3D();
        for (let i = 0; i < treeCount; i++) {
            let x = (Math.random() - 0.5) * 500;
            let z = (Math.random() - 0.5) * 500;
            if (x > -12 && x < 12) { x += 25; } 

            dummy.position.set(x, 2, z);
            dummy.updateMatrix();
            trunkMesh.setMatrixAt(i, dummy.matrix);

            dummy.position.set(x, 6, z);
            dummy.updateMatrix();
            leavesMesh.setMatrixAt(i, dummy.matrix);

            treePositions.push({ x: x, z: z });
        }
        scene.add(trunkMesh);
        scene.add(leavesMesh);

        // --- 4. CONTROLS (THE FIX) ---
        
        const inputs = { fwd: 0, right: 0 };
        const velocity = new THREE.Vector3();
        
        // --- PC CONTROLS ---
        document.addEventListener('keydown', (e) => {
            if(e.code === 'KeyW') inputs.fwd = 1;
            if(e.code === 'KeyS') inputs.fwd = -1;
            if(e.code === 'KeyA') inputs.right = -1;
            if(e.code === 'KeyD') inputs.right = 1;
        });
        document.addEventListener('keyup', (e) => {
            if(e.code === 'KeyW' || e.code === 'KeyS') inputs.fwd = 0;
            if(e.code === 'KeyA' || e.code === 'KeyD') inputs.right = 0;
        });
        document.addEventListener('click', () => document.body.requestPointerLock());
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
            }
        });

        // --- MOBILE CONTROLS (FIXED MULTITOUCH) ---
        
        const stickContainer = document.getElementById('stick-container');
        const stickKnob = document.getElementById('joystick-knob');
        const lookZone = document.getElementById('look-zone');

        // Variables to track specific fingers
        let joystickTouchId = null;
        let lookTouchId = null;
        let lastLookX = 0;
        let lastLookY = 0;

        // --- JOYSTICK LOGIC ---
        stickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // Agar pehle se koi finger joystick par nahi hai
            if (joystickTouchId === null) {
                const touch = e.changedTouches[0];
                joystickTouchId = touch.identifier; // Finger ID note kar li
                updateJoystick(touch);
            }
        }, {passive: false});

        stickContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (joystickTouchId !== null) {
                // Sirf wahi finger dhoondo jo joystick wali hai
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchId) {
                        updateJoystick(e.changedTouches[i]);
                        break;
                    }
                }
            }
        }, {passive: false});

        const endJoystick = (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === joystickTouchId) {
                    joystickTouchId = null;
                    inputs.fwd = 0;
                    inputs.right = 0;
                    stickKnob.style.transform = `translate(-50%, -50%)`;
                    break;
                }
            }
        };
        stickContainer.addEventListener('touchend', endJoystick);
        stickContainer.addEventListener('touchcancel', endJoystick);

        function updateJoystick(touch) {
            const rect = stickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const dx = touch.clientX - centerX;
            const dy = touch.clientY - centerY;
            
            const maxDist = 40;
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxDist);
            const angle = Math.atan2(dy, dx);
            
            const joyX = Math.cos(angle) * dist;
            const joyY = Math.sin(angle) * dist;

            stickKnob.style.transform = `translate(calc(-50% + ${joyX}px), calc(-50% + ${joyY}px))`;

            // Normalize values -1 to 1
            inputs.right = joyX / maxDist;
            inputs.fwd = -(joyY / maxDist);
        }

        // --- LOOK LOGIC ---
        lookZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (lookTouchId === null) {
                const touch = e.changedTouches[0];
                lookTouchId = touch.identifier; // Camera ID note kar li
                lastLookX = touch.clientX;
                lastLookY = touch.clientY;
            }
        }, {passive: false});

        lookZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (lookTouchId !== null) {
                // Find the specific look finger
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.identifier === lookTouchId) {
                        const dx = touch.clientX - lastLookX;
                        const dy = touch.clientY - lastLookY;

                        camera.rotation.y -= dx * 0.005; // Sensitivity
                        camera.rotation.x -= dy * 0.005;
                        camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));

                        lastLookX = touch.clientX;
                        lastLookY = touch.clientY;
                        break;
                    }
                }
            }
        }, {passive: false});

        const endLook = (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === lookTouchId) {
                    lookTouchId = null;
                    break;
                }
            }
        };
        lookZone.addEventListener('touchend', endLook);
        lookZone.addEventListener('touchcancel', endLook);


        // --- 5. GAME LOOP ---
        camera.position.set(0, 2, 20);
        camera.rotation.order = "YXZ";

        function checkCollisions() {
            const collisionDist = 2.0; 
            const pX = camera.position.x;
            const pZ = camera.position.z;

            for (let i = 0; i < treePositions.length; i++) {
                const tX = treePositions[i].x;
                const tZ = treePositions[i].z;
                
                if (Math.abs(pX - tX) > 3 || Math.abs(pZ - tZ) > 3) continue;

                const distSq = (pX - tX)**2 + (pZ - tZ)**2;
                if (distSq < collisionDist * collisionDist) {
                    const angle = Math.atan2(pZ - tZ, pX - tX);
                    camera.position.x = tX + Math.cos(angle) * collisionDist;
                    camera.position.z = tZ + Math.sin(angle) * collisionDist;
                }
            }
        }

        let prevTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1);
            prevTime = time;

            // Friction
            velocity.x -= velocity.x * 5.0 * delta;
            velocity.z -= velocity.z * 5.0 * delta;

            if (inputs.fwd !== 0 || inputs.right !== 0) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0; direction.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(camera.up, direction).normalize();

                const speed = 60.0 * delta; // Speed settings
                
                // Move logic corrected
                velocity.x += (direction.x * inputs.fwd - right.x * inputs.right) * speed;
                velocity.z += (direction.z * inputs.fwd - right.z * inputs.right) * speed;
            }

            camera.position.x += velocity.x * delta;
            camera.position.z += velocity.z * delta;

            checkCollisions();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>